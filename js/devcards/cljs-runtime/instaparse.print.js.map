{"version":3,"sources":["instaparse/print.cljc"],"mappings":"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","names":["instaparse.print/paren-for-tags","tag-set","hidden?","parser","cljs.core/not","G__55803","G__55804","instaparse.print/combinators->str","instaparse.print/paren-for-compound","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","instaparse.print/regexp-replace","s","G__55805","instaparse.print/regexp->str","r","clojure.string/replace","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","instaparse.print/number->hex-padded","n","p__55806","map__55807","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","instaparse.print/char-range->str","lo","hi","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","var_args","G__55810","js/Error","p__55811","map__55812","p","instaparse.print.combinators__GT_str.cljs$core$IFn$_invoke$arity$2","parser1","parser2","parsers","tag","G__55814","cljs.core/Keyword","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","clojure.string.join.cljs$core$IFn$_invoke$arity$2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","sb__4720__auto__","goog.string/StringBuffer","*print-newline*-orig-val__55815","cljs.core/*print-newline*","*print-fn*-orig-val__55816","cljs.core/*print-fn*","*print-newline*-temp-val__55817","*print-fn*-temp-val__55818","x__4721__auto__","cljs.core.pr.cljs$core$IFn$_invoke$arity$variadic","*print-newline*-orig-val__55819","*print-fn*-orig-val__55820","*print-newline*-temp-val__55821","*print-fn*-temp-val__55822","instaparse.print/rule->str","non-terminal","cljs.core/name","instaparse.print.combinators__GT_str.cljs$core$IFn$_invoke$arity$1","p__55823","map__55824","instaparse.print/Parser->str","grammar","start","cljs.core/cons","iter__4582__auto__","s__55827","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4580__auto__","size__4581__auto__","cljs.core/count","b__55829","cljs.core/chunk-buffer","i__55828","vec__55830","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__55826","cljs.core/chunk-rest","vec__55833","cljs.core/first","cljs.core/rest","cljs.core/chunk-first"],"sourcesContent":["(ns instaparse.print\r\n  \"Facilities for taking parsers and grammars, and converting them to strings.\r\n   Used for pretty-printing.\"\r\n  (:require [clojure.string :as str]))\r\n\r\n(declare combinators->str) ; mutual recursion\r\n\r\n(defn paren-for-tags [tag-set hidden? parser]\r\n  (if (and (not hidden?) (tag-set (parser :tag)))\r\n    (str \"(\" (combinators->str parser false) \")\")\r\n    (combinators->str parser false)))\r\n\r\n(def paren-for-compound \r\n  (partial paren-for-tags #{:alt :ord :cat}))\r\n\r\n(defn regexp-replace\r\n  \"Replaces whitespace characters with escape sequences for better printing\" \r\n  [s]\r\n  (case s\r\n    \"\\n\" \"\\\\n\"\r\n    \"\\b\" \"\\\\b\"\r\n    \"\\f\" \"\\\\f\"\r\n    \"\\r\" \"\\\\r\"\r\n    \"\\t\" \"\\\\t\"\r\n    s)) \r\n\r\n(defn regexp->str [r]\r\n  (str/replace \r\n    (str \"#\\\"\"\r\n         #?(:clj (str r)\r\n            :cljs (subs (.-source r) 1))\r\n         \"\\\"\")\r\n    #\"[\\s]\" regexp-replace))\r\n\r\n#?(:clj\r\n   (defn char-range->str [{:keys [lo hi]}]\r\n     (if (= lo hi)\r\n       (format \"%%x%04x\" lo)\r\n       (format \"%%x%04x-%04x\" lo hi)))\r\n\r\n   :cljs\r\n   (do\r\n     (defn number->hex-padded [n]\r\n       (if (<= n 0xFFF)\r\n         (.substr (str \"0000\" (.toString n 16)) -4)\r\n         (.toString n 16)))\r\n\r\n     (defn char-range->str [{:keys [lo hi]}]\r\n       (if (= lo hi)\r\n         (str \"%x\" (number->hex-padded lo))\r\n         (str \"%x\" (number->hex-padded lo) \"-\" (number->hex-padded hi))))))\r\n\r\n(defn combinators->str\r\n  \"Stringifies a parser built from combinators\"\r\n  ([p] (combinators->str p false))\r\n  ([{:keys [parser parser1 parser2 parsers tag] :as p} hidden?]\r\n    (if (and (not hidden?) (:hide p))\r\n      (str \\< (combinators->str p true) \\>)\r\n      (case tag\r\n        :epsilon \"\\u03b5\"\r\n        :opt (str (paren-for-compound hidden? parser) \"?\")\r\n        :plus (str (paren-for-compound hidden? parser) \"+\")\r\n        :star (str (paren-for-compound hidden? parser) \"*\")\r\n        :rep (if (not= (:min p) (:max p))\r\n               (str (paren-for-compound hidden? parser) \\{ \r\n                    (:min p) \\, (:max p) \\})\r\n               (str (paren-for-compound hidden? parser) \\{ \r\n                    (:min p)\\}))\r\n        :alt (str/join \" | \" (map (partial paren-for-tags #{:ord} hidden?) parsers))\r\n        :ord (str (paren-for-tags #{:alt} hidden? parser1)\r\n                  \" / \"\r\n                  (paren-for-tags #{:alt} hidden? parser2))\r\n        :cat (str/join \" \" (map (partial paren-for-tags #{:alt :ord} hidden?) parsers))\r\n        :string (with-out-str (pr (:string p)))\r\n        :string-ci (with-out-str (pr (:string p)))\r\n        :char (char-range->str p)\r\n        :regexp (regexp->str (:regexp p))\r\n        :nt (subs (str (:keyword p)) 1)\r\n        :look (str \"&\" (paren-for-compound hidden? parser))\r\n        :neg (str \"!\" (paren-for-compound hidden? parser))))))\r\n  \r\n(defn rule->str\r\n  \"Takes a non-terminal symbol and a parser built from combinators,\r\n   and returns a string for the rule.\"\r\n  [non-terminal parser]\r\n  (if (= (-> parser :red :reduction-type) :raw)\r\n    (str \\< (name non-terminal) \\> \r\n         \" = \" \r\n         (combinators->str parser))\r\n    (str (name non-terminal)\r\n         \" = \" \r\n         (combinators->str parser))))\r\n\r\n(defn Parser->str\r\n  \"Takes a Parser object, i.e., something with a grammar map and a start \r\n   production keyword, and stringifies it.\" \r\n  [{grammar :grammar start :start-production}]\r\n  (str/join \\newline\r\n            (cons\r\n              ; Put starting production first\r\n              (rule->str start (grammar start))\r\n              ; Then the others\r\n              (for [[non-terminal parser] grammar\r\n                    :when (not= non-terminal start)]\r\n                (rule->str non-terminal parser)))))\r\n"]}