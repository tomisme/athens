{"version":3,"sources":["sci/impl/fns.cljc"],"mappings":"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","names":["sci.impl.fns/throw-arity","fn-name","macro?","args","js/Error","actual-count","cljs.core/count","cljs.core/PROTOCOL_SENTINEL","this__4428__auto__","writer__4429__auto__","opt__4430__auto__","cljs.core/-write","sci.impl.fns/Recur","sci.impl.fns/->Recur","val","this","p__58543","map__58544","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","sci.impl.fns/parse-fn-args+body","ctx","interpret","eval-do*","fixed-arity","var-arg-name","params","body","_m","with-meta?","min-var-args-arity","f","bindings","cljs.core/seq","ret","fp","cljs.core/first","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/second","cljs.core/next","G__58549","G__58550","recur?","recur-val","sci.impl.types/getVal","vec__58552","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__58555","fixed-args","rest-args","cljs.core.subvec.cljs$core$IFn$_invoke$arity$3","cljs.core.subvec.cljs$core$IFn$_invoke$arity$2","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core/with-meta","sci.impl.fns/lookup-by-arity","arities","arity","cljs.core/some","map__58560","cljs.core/meta","or__4185__auto__","and__4174__auto__","p__58564","map__58565","sci.impl.fns/eval-fn","fn-bodies","self-ref","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","call-self","cljs.core/deref","cljs.core/assoc-in","single-arity?","p1__58562#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","arg-count","temp__5733__auto__","p1__58563#","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$2","cljs.core/reset!"],"sourcesContent":["(ns sci.impl.fns\n  {:no-doc true}\n  (:require [sci.impl.types :as t]))\n\n(defn throw-arity [fn-name macro? args]\n  (throw (new #?(:clj Exception\n                 :cljs js/Error)\n              (let [actual-count (if macro? (- (count args) 2)\n                                     (count args))]\n                (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))\n\n(deftype Recur #?(:clj [val]\n                  :cljs [val])\n  t/IBox\n  (getVal [this] val))\n\n(defn parse-fn-args+body\n  [ctx interpret eval-do*\n   {:sci.impl/keys [fixed-arity var-arg-name params body] :as _m}\n   fn-name macro? with-meta?]\n  (let [min-var-args-arity (when var-arg-name fixed-arity)\n        f (fn run-fn [& args]\n            (let [;; tried making bindings a transient, but saw no perf improvement (see #246)\n                  bindings (:bindings ctx)\n                  bindings\n                  (loop [args (seq args)\n                         params (seq params)\n                         ret bindings]\n                    (if params\n                      (let [fp (first params)]\n                        (if (= '& fp)\n                          (assoc ret (second params) args)\n                          (do\n                            (when-not args\n                              (throw-arity fn-name macro? args))\n                            (recur (next args) (next params)\n                                   (assoc ret fp (first args))))))\n                      (do\n                        (when args\n                          (throw-arity fn-name macro? args))\n                        ret)))\n                  ctx (assoc ctx :bindings bindings)\n                  ret (if (= 1 (count body))\n                        (interpret ctx (first body))\n                        (eval-do* ctx body))\n                  ;; m (meta ret)\n                  recur? (instance? Recur ret)]\n              (if recur?\n                (let [recur-val (t/getVal ret)]\n                  (if min-var-args-arity\n                    (let [[fixed-args [rest-args]]\n                          [(subvec recur-val 0 min-var-args-arity)\n                           (subvec recur-val min-var-args-arity)]]\n                      (recur (into fixed-args rest-args)))\n                    (recur recur-val)))\n                ret)))]\n    (if with-meta?\n      (with-meta\n        f\n        (if min-var-args-arity\n          {:sci.impl/min-var-args-arity min-var-args-arity}\n          {:sci.impl/fixed-arity fixed-arity}))\n      f)))\n\n(defn lookup-by-arity [arities arity]\n  (some (fn [f]\n          (let [{:sci.impl/keys [fixed-arity min-var-args-arity]} (meta f)]\n            (when (or (= arity fixed-arity )\n                      (and min-var-args-arity\n                           (>= arity min-var-args-arity)))\n              f))) arities))\n\n(defn eval-fn [ctx interpret eval-do* {:sci.impl/keys [fn-bodies fn-name] :as f}]\n  (let [macro? (:sci/macro f)\n        self-ref (atom nil)\n        call-self (fn [& args]\n                    (apply @self-ref args))\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] call-self)\n                ctx)\n        single-arity? (= 1 (count fn-bodies))\n        f (if single-arity?\n            (parse-fn-args+body ctx interpret eval-do* (first fn-bodies) fn-name macro? false)\n            (let [arities (map #(parse-fn-args+body ctx interpret eval-do* % fn-name macro? true) fn-bodies)]\n              (fn [& args]\n                (let [arg-count (count args)]\n                  (if-let [f (lookup-by-arity arities arg-count)]\n                    (apply f args)\n                    (throw (new #?(:clj Exception\n                                   :cljs js/Error)\n                                (let [actual-count (if macro? (- arg-count 2)\n                                                       arg-count)]\n                                  (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))))))\n        f (if macro?\n            (vary-meta\n             f\n             #(assoc % :sci/macro macro?))\n            f)]\n    (reset! self-ref f)\n    f))\n\n;;;; Scratch\n\n(comment\n  )\n"]}