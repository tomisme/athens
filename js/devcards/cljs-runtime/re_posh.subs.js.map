{"version":3,"sources":["re_posh/subs.cljc"],"mappings":"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","names":["js/re-posh","js/re-posh.subs","js/re-posh.subs.execute-sub","method-table__4672__auto__","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","prefer-table__4673__auto__","method-cache__4674__auto__","cached-hierarchy__4675__auto__","hierarchy__4676__auto__","cljs.core.get.cljs$core$IFn$_invoke$arity$3","fexpr__63198","cljs.core/MultiFn","cljs.core.symbol.cljs$core$IFn$_invoke$arity$2","re-posh.subs/execute-sub","p__63199","map__63200","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","query","variables","pre-q","cljs.core/deref","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","posh.reagent/q","re-posh.db/store","cljs.core.into.cljs$core$IFn$_invoke$arity$2","p__63202","map__63203","pattern","id","G__63205","G__63206","G__63207","posh.reagent/pull","p__63208","map__63209","ids","G__63211","G__63212","G__63213","posh.reagent/pull-many","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","re-posh.subs/reg-sub","seq63214","G__63215","cljs.core/first","cljs.core/next","self__4776__auto__","query-id","args","config-fn","cljs.core/last","input-args","cljs.core/butlast","err-header","inputs-fn","G__63216","cljs.core/count","_","f","cljs.core/fn?","re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic","vec__63217","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","marker","vec","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","re-frame.core/subscribe","pairs","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","markers","cljs.core.map.cljs$core$IFn$_invoke$arity$2","vecs","cljs.core/every?","cljs.core/vector?","re-frame.core/reg-sub-raw","params","G__63220","G__63221","G__63222","reagent.ratom/make-reaction","inputs","signals","cljs.core/list?","G__63223","re-posh.subs/reg-query-sub","sub-name","re_posh.subs.reg_sub.cljs$core$IFn$_invoke$arity$variadic","p__63226","vec__63227","seq__63228","cljs.core/seq","first__63229","re-posh.subs/reg-pull-sub","p__63234","vec__63235","re-posh.subs/reg-pull-many-sub","p__63238","vec__63239"],"sourcesContent":["(ns re-posh.subs\n  (:require\n   [re-frame.core :as r]\n   [re-frame.loggers :refer [console]]\n   [re-posh.db :refer [store]]\n   [reagent.ratom :refer-macros [reaction]]\n   [posh.reagent  :as p]))\n\n(defmulti execute-sub :type)\n\n(defmethod execute-sub :query\n  [{:keys [query variables]}]\n  (let [pre-q (partial p/q query @store)]\n    (apply pre-q (into [] variables))))\n\n(defmethod execute-sub :pull\n  [{:keys [pattern id]}]\n  (p/pull @store pattern id))\n\n(defmethod execute-sub :pull-many\n  [{:keys [pattern ids]}]\n  (p/pull-many @store pattern ids))\n\n(defn reg-sub\n  \"For a given `query-id` register a `config` function and input `signals`\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a function that generates config for query or pull for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A config function is always the last argument and it has this general form:\n  `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the config functions gets as a first argument.\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-config-fn)   ;; (fn [db v]  ... a-value)\n     The node's input signal defaults to datascript database, and the value within `ds` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here, the form is (fn [db v] ... signal | [signal])\n       config-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many.\n     The values from the nominated signals will be supplied as the 1st argument to the\n     config function - either a singleton or sequence, paralleling\n     the structure returned by the signal function.\n     Here, is an example signal-fn, which returns a vector of input signals.\n       (fn [query-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n     For that signal function, the config function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n     then the config function must be written to expect a single value\n     as the 1st argument:\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n  \"\n  [query-id & args]\n  (let [config-fn  (last args)\n        input-args (butlast args)\n        err-header (str \"re-posh: reg-sub for \" query-id \", \")\n        inputs-fn  (case (count input-args)\n                     ;; no `inputs` function provided - give the default\n                     0 (fn\n                         ([_] nil)\n                         ([_ _] nil))\n\n                     ;; a single `inputs` fn\n                     1 (let [f (first input-args)]\n                         (when-not (fn? f)\n                           (console :error err-header \"2nd argument expected to ba an inputs function, got: \" f))\n                         f)\n\n                     ;; one sugar pair\n                     2 (let [[marker vec] input-args]\n                         (when-not (= :<- marker)\n                           (console :error err-header \"expected :<-, got: \" marker))\n                         (fn inp-fn\n                           ([_] (r/subscribe vec))\n                           ([_ _] (r/subscribe vec))))\n\n                     ;; multiple sugar pairs\n                     (let [pairs (partition 2 input-args)\n                           markers (map first pairs)\n                           vecs (map last pairs)]\n                       (when-not (and (every? #{:<-} markers) (every? vector? vecs))\n                         (console :error err-header \"expected pairs of :<- and vectors, got:\" pairs))\n                       (fn inp-fn\n                         ([_] (map r/subscribe vecs))\n                         ([_ _] (map r/subscribe vecs)))))]\n    (r/reg-sub-raw\n     query-id\n     (fn [_ params]\n       (if (= (count input-args) 0)\n         ;; if there is no inputs-fn provided (or sugar version) don't wrap anything in reaction,\n         ;; just return posh's query or pull\n         (execute-sub (config-fn @@store params))\n         (reaction\n          (let [inputs (inputs-fn params)\n                signals (if (list? inputs)\n                          (map deref inputs)\n                          (deref inputs))]\n            @(execute-sub (config-fn signals params)))))))))\n\n(defn reg-query-sub\n  \"Syntax sugar for writing queries. It allows writing query subscription\n   in a very simple way:\n\n  (re-posh/reg-query-sub\n   :query-id\n   '[:find ...\n     :in $ $1 $2  ;; <- all variables go here\n     :where ...])\n\n  It's possible to subscibe to this query with\n\n  (re-posh/subscribe [:query-id var-1 var-2])\n\n  so that variables `var-1` and `var-2` will be automatically sent to `:in` form\n  \"\n  [sub-name query]\n  (reg-sub\n   sub-name\n   (fn [_ [_ & params]]\n     {:type      :query\n      :query     query\n      :variables params})))\n\n(defn reg-pull-sub\n  \"Syntax sugar for writing pull queries. It allows writing pull subscription\n  in a very simple way:\n\n  (re-posh/reg-pull-sub\n   :pull-id\n   '[*]) ;;<- pull pattern\n\n  It's possible to subscribe to this pull query with\n\n  (re-posh/subscibe [:pull-id id])\n\n  Where id is an entity id\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ id]]\n     {:type    :pull\n      :pattern pattern\n      :id      id})))\n\n(defn reg-pull-many-sub\n  \"Syntax sugar for writing pull-many queries.\n  Same as reg-pull-sub but takes vector of eids under key :ids\n\n  (reg-pull-many-sub\n   :things\n   '[*])\n\n  It's possible to subscribe to this pull-many query with\n\n  (re-posh/subscribe [:things ids])\n\n  Where ids is a sequence of entity ids\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ ids]]\n     {:type    :pull-many\n      :pattern pattern\n      :ids     ids})))\n"]}