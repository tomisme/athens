{"version":3,"sources":["day8/re_frame/forward_events_fx.cljs"],"mappings":";;;AAIA;;;;;;;AAAA,AAAMA,AAMHC;AANH,AAOE,AAAMA;AAAN,AACE,AAAM,AAACC,AAAID;AAAeA;;AAA1B,AACM,AAAAE,AAAUF;AAAe,AAAAG;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAeG;AAAf,AACE,AAACC,AAAER,AAAcM;;;AAFlD,AAGM,AAACG,AAAMT;AAAe,AAAKU;AAAL,AACE,AAACF,AAAER,AAAcU;;;AAJ/C,AAKY,AACE,AAAA,AAAA,AAACC,AAAQ,AAAA,AAAK,AAACC,AAAOZ,AAEJA;;;;;;AATlC;;;AAYF,AAAAa,AAAA;AAAAC,AAEE,AAAME,AAAkB,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAA,AAAUK;AAAV,AAAAD,AAAAJ,AAAA,AAAmBM;AAAnB,AAAAF,AAAAJ,AAAA,AAA8BO;AAA9B,AAAAH,AAAAJ,AAAA,AAAuCQ;AAAvC,AAAAJ,AAAAJ,AAAA,AAA8CS;AAA9C,AACE,AAAMpB,AAAE,AAAA,AAAA,AAAA,AAAA,AAAAqB,AAAA,AAAA,AAAA,AAAA,AAAQ,AAACC,AAAKN,AAAG,AAAA,AAA6FA;AAChHhB,AAAE,AAAA,AAAA,AAAA,AAAA,AAAAqB,AAAA,AAAA,AAAA,AAAA,AAAQ,AAAI,AAAA,AAAA,AAACpB,AAAiB,AAAA,AAAIe,AAAEO,AAAKC,AAC7B,AAAA,AAAA,AAAA,AAAA,AAACvB,AAAoC,AAAA,AAAIe,AAAEO,AAAKC,AAAO,AAAA,AAA0E,AAAA,AAAIR,AAAEO,AAAKC;AAFhK,AAGE,AAAIP;AACF,AAACQ,AAAoCR;;AACrC,AAAMS,AAAuB,AAACC,AAAInC,AAAiB2B;AAC7CS,AAAuB,AAAKzB,AAAQH;AAAb,AACE,AAAM,AAAC6B,AAAK,AAAKC;AAAL,AAAW,AAACA,AAAAA,AAAAA,AAAK3B,AAAAA;AACjBuB;AADZ,AAEE,AAAAK,AAAmB,AAACE,AAAKb,AAAYjB;AAArC,AAAA,AAAA4B,AAAAA,AAACC,AAAAA,AAAAA;;AAFH;;;AAF/B,AAKE,AAACE,AAAiChB,AAASU;;;AAX3E,AAYE,AAAKO;AAAL,AACE,AACE,AAACb,AAAKa;AAAK,AAAC1B,AAAkB0B;;AADhC,AAEE,AAACC,AAAYD;AAAK,AAACE,AAAM,AAACV,AAAIlB,AAAkB0B;;AAFlD,AAGQ,AAAAG,AAAA;AAAAC,AAAA;AAAAC,AAAuFL;AAAvF,AAAA,AAAAG,AAAAC,AAAAC,AAAAF,AAAAC,AAAAC,AAACC,AAAAA,AAAAA;;;;;;AAlBf,AAAA,AAAAnC,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA","names":["day8.re-frame.forward-events-fx/as-callback-pred","callback-pred","cljs.core/fn?","cljs.core/Keyword","p__61251","vec__61252","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","event-id","_","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/coll?","event-v","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","G__61255","G__61256","re-frame.core/reg-fx","process-one-entry","p__61257","map__61258","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","m","unregister","register","events","dispatch-to","js/Error","cljs.core/map?","cljs.core/keys","cljs.core/set","re-frame.core/remove-post-event-callback","events-preds","cljs.core.map.cljs$core$IFn$_invoke$arity$2","post-event-callback-fn","cljs.core/some","pred","G__61260","re-frame.core/dispatch","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2","val","cljs.core/sequential?","cljs.core.doall.cljs$core$IFn$_invoke$arity$1","G__61261","G__61262","G__61263","re-frame.core/console"],"sourcesContent":["(ns day8.re-frame.forward-events-fx\n  (:require [re-frame.core :as re-frame]))\n\n\n(defn as-callback-pred\n  \"Looks at the required-events items and returns a predicate which\n  will either\n  - match only the event-keyword if a keyword is supplied\n  - match the entire event vector if a collection is supplied\n  - returns a callback-pred if it is a fn\"\n  [callback-pred]\n  (when callback-pred\n    (cond (fn? callback-pred) callback-pred\n          (keyword? callback-pred) (fn [[event-id _]]\n                                     (= callback-pred event-id))\n          (coll? callback-pred) (fn [event-v]\n                                  (= callback-pred event-v))\n          :else (throw\n                  (ex-info (str (pr-str callback-pred)\n                             \" isn't an event predicate\")\n                    {:callback-pred callback-pred})))))\n\n\n(re-frame/reg-fx\n  :forward-events\n  (let [process-one-entry (fn [{:as m :keys [unregister register events dispatch-to]}]\n                            (let [_ (assert (map? m) (str \"re-frame: effects handler for :forward-events expected a map or a list of maps. Got: \" m))\n                                  _ (assert (or (= #{:unregister} (-> m keys set))\n                                                (= #{:register :events :dispatch-to} (-> m keys set))) (str \"re-frame: effects handler for :forward-events given wrong map keys\" (-> m keys set)))]\n                              (if unregister\n                                (re-frame/remove-post-event-callback unregister)\n                                (let [events-preds           (map as-callback-pred events)\n                                      post-event-callback-fn (fn [event-v _]\n                                                               (when (some (fn [pred] (pred event-v))\n                                                                           events-preds)\n                                                                 (re-frame/dispatch (conj dispatch-to event-v))))]\n                                  (re-frame/add-post-event-callback register post-event-callback-fn)))))]\n    (fn [val]\n      (cond\n        (map? val) (process-one-entry val)\n        (sequential? val) (doall (map process-one-entry val))\n        :else (re-frame/console :error \":forward-events expected a map or a list of maps, but got: \" val)))))\n"]}