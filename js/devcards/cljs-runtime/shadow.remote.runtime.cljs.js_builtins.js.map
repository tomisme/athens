{"version":3,"sources":["shadow/remote/runtime/cljs/js_builtins.cljs"],"mappings":";;;;AAKA,AAAA,AAAA,AAAAA,AAAAC,AAAA,AAAA;;AAAA,AAAAC,AAAAC;AAAAC,AAAA;AAAAC,AAOE,AAASI;AAAT,AACE,AAAA,AAAQ,AAAY,AAAaA,AAAGC;AAClCD;;AACA,AAACE,AAEM,AAACE,AACC,AAAKC,AAAEC,AAGT,AAACI;AAHC,AACE,AAACH,AAAOF,AAAEC,AAAI,AAACE,AAASR,AAAEM;AAJrC,AAAA,AAAA,AACO,AAACH,AAAaH,AAIZ,AAAA,AAACS,AAGA,AAAKE,AAAKC,AAAEC;AAAZ,AACE,AAACL,AAASR,AAAEY;;;;AAnB9B,AAAA,AAAArB,AAAAE,AAAAE,AAAAC;;AAAA,AAAA,AAAAL,AAAAC,AAAA,AAAA;;AAAA,AAAAK,AAAAH;AAAAI,AAAA;AAAAC,AAsBE,AAASC;AAAT,AACE,AAACc,AAAId;;AAvBT,AAAA,AAAAT,AAAAM,AAAAC,AAAAC","names":["goog.object/set","clojure.core.protocols/Datafiable","G__60798","clojure.core.protocols/datafy","G__60799","G__60800","G__60801","G__60802","G__60803","o","js/Object.prototype","cljs.core/with-meta","goog.object/getKeys","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","m","key","cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3","goog.object/get","cljs.core/transient","cljs.core/persistent!","coll","k","v","cljs.core/vec"],"sourcesContent":["(ns shadow.remote.runtime.cljs.js-builtins\n  (:require\n    [goog.object :as gobj]\n    [clojure.core.protocols :as p]))\n\n(extend-protocol p/Datafiable\n  ;; FIXME: this is kind of a bad idea\n  ;; can't do this for all objects, since none of the CLJS types implement this\n  ;; protocol either. the protocol dispatch will end up using object\n  ;; FIXME: this could detect CLJS types to some extent\n  ;; or should it just implement the protocols for the types?\n  object\n  (datafy [o]\n    (if-not (identical? (.-__proto__ o) js/Object.prototype)\n      o\n      (with-meta\n        (->> (gobj/getKeys o)\n             (reduce\n               (fn [m key]\n                 (assoc! m key (gobj/get o key)))\n               (transient {}))\n             (persistent!))\n\n        {`p/nav (fn [coll k v]\n                  (gobj/get o k))})))\n\n  array\n  (datafy [o]\n    (vec o)))\n"]}